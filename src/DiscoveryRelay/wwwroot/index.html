<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discovery Relay WebSocket Test</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="hero-section">
        <img src="discovery-relay.jpg" alt="Discovery Relay Illustration" class="hero-image">
        <div class="hero-content">
            <h1>Discovery Relay WebSocket Test</h1>
            <p>A Nostr relay specialized in discovery services and NIP-11 information.</p>
        </div>
    </div>

    <div class="card" id="nip11-info">
        <h2>NIP-11 Relay Information</h2>
        <div id="nip11-loading">Loading relay information...</div>
        <div id="nip11-data" style="display: none;">
            <div class="info-grid">
                <div class="info-label">Name:</div>
                <div class="info-value" id="relay-name">-</div>

                <div class="info-label">Description:</div>
                <div class="info-value" id="relay-description">-</div>

                <div class="info-label">Contact:</div>
                <div class="info-value" id="relay-contact">-</div>

                <div class="info-label">Software:</div>
                <div class="info-value" id="relay-software">-</div>

                <div class="info-label">Version:</div>
                <div class="info-value" id="relay-version">-</div>

                <div class="info-label">Supported NIPs:</div>
                <div class="info-value">
                    <div class="nips-list" id="relay-nips">-</div>
                </div>

                <div class="info-label">Limitations:</div>
                <div class="info-value" id="relay-limitations">-</div>

                <div class="info-label">Retention Policy:</div>
                <div class="info-value" id="relay-retention">-</div>

                <div class="info-label">Publish Policy:</div>
                <div class="info-value" id="relay-publish">-</div>

                <div class="info-label">Fees:</div>
                <div class="info-value" id="relay-fees">-</div>

                <div class="info-label">Privacy Policy:</div>
                <div class="info-value" id="relay-privacy">-</div>
            </div>
        </div>
        <div id="nip11-error" style="display: none; color: #a94442;"></div>
        <button id="refresh-nip11-btn" style="margin-top: 15px;">Refresh Information</button>
    </div>

    <div class="tab">
        <button class="tablinks active" onclick="openTab(event, 'testing')">Testing</button>
        <button class="tablinks" onclick="openTab(event, 'sync')">Sync</button>
        <button class="tablinks" onclick="openTab(event, 'did')">DID Lookup</button>
    </div>

    <div id="testing" class="tabcontent" style="display: block;">
        <div class="container">
            <div class="card">
                <h2>WebSocket Connection</h2>
                <div id="connectionStatus" class="status disconnected">Disconnected</div>
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" disabled>Disconnect</button>
            </div>

            <div class="card">
                <h2>Send Message</h2>
                <textarea id="messageInput" rows="3" placeholder="Type your message here..."></textarea>
                <button id="sendBtn" disabled>Send Message</button>
            </div>

            <div class="card">
                <h2>Nostr Protocol Test</h2>
                <div>
                    <h3>Subscribe</h3>
                    <input id="subscriptionId" type="text" placeholder="Subscription ID (e.g. sub:1)" value="sub:1">
                    <input id="authorId" type="text" placeholder="Author ID (hex)"
                        value="17e2889fba01021d048a13fd0ba108ad31c38326295460c21e69c43fa8fbe515">
                    <select id="kindId">
                        <option value="3">Kind 3 (Contacts)</option>
                        <option value="10002" selected>Kind 10002 (Relay List Metadata)</option>
                    </select>
                    <button id="subscribeBtn" disabled>Send REQ</button>
                </div>
                <div style="margin-top: 10px;">
                    <h3>Unsubscribe</h3>
                    <input id="closeSubscriptionId" type="text" placeholder="Subscription ID (e.g. sub:1)"
                        value="sub:1">
                    <button id="unsubscribeBtn" disabled>Send CLOSE</button>
                </div>
                <div style="margin-top: 15px;">
                    <h3>Send Event</h3>
                    <input id="eventPubkey" type="text" placeholder="Public Key (hex)"
                        value="17e2889fba01021d048a13fd0ba108ad31c38326295460c21e69c43fa8fbe515">
                    <select id="eventKind">
                        <option value="3">Kind 3 (Contacts)</option>
                        <option value="10002" selected>Kind 10002 (Relay List Metadata)</option>
                    </select>
                    <input id="eventId" type="text" placeholder="Event ID (hex, auto-generated if empty)" value="">
                    <textarea id="eventContent" rows="2" placeholder="Content"></textarea>
                    <input id="eventSig" type="text" placeholder="Signature (hex, for testing only)" value="">
                    <button id="sendEventBtn" disabled>Send EVENT</button>
                </div>
                <div class="alert"
                    style="margin-top: 10px; color: #856404; background-color: #fff3cd; padding: 10px; border-radius: 4px;">
                    <strong>Note:</strong> This relay only accepts events of kind 3 (Contacts) and 10002 (Relay List
                    Metadata)
                </div>
            </div>

            <div class="card">
                <h2>Message Log</h2>
                <div id="log"></div>
                <button id="clearLogBtn">Clear Log</button>
            </div>

            <div class="card">
                <h2>REST API Test</h2>
                <input id="broadcastInput" type="text" placeholder="Message to broadcast">
                <button id="broadcastBtn">Broadcast via REST API</button>
            </div>
        </div>
    </div>

    <div id="sync" class="tabcontent">
        <div class="container">
            <div class="card">
                <h2>Relay Synchronization</h2>
                <p>Add relay URLs to fetch data from and sync to local relay.</p>

                <div id="relayList">
                    <div class="relay-item">
                        <input type="text" class="relay-url" placeholder="wss://relay.example.com"
                            value="wss://relay.damus.io">
                        <button class="remove-relay">Remove</button>
                        <span class="relay-status"></span>
                    </div>
                </div>

                <button id="addRelayBtn">Add Relay</button>
                <button id="testRelaysBtn">Test Connections</button>

                <h3>Sync Options</h3>
                <div>
                    <label><input type="checkbox" id="syncKind10002" checked> Sync Kind 10002 (Relay List
                        Metadata)</label>
                </div>
                <div>
                    <label><input type="checkbox" id="syncKind3" checked> Sync Kind 3 (Contacts)</label>
                </div>
                <div>
                    <label>Limit: <input type="number" id="syncLimit" value="50" min="1" max="500"></label>
                </div>

                <progress id="syncProgress" value="0" max="100" style="display: none;"></progress>
                <div id="syncStats"></div>

                <button id="startSyncBtn">Start Sync</button>
                <button id="stopSyncBtn" disabled>Stop Sync</button>
            </div>

            <div class="card">
                <h2>Sync Log</h2>
                <div id="syncLog" class="log"
                    style="height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background-color: #f5f5f5; font-family: monospace;">
                </div>
                <button id="clearSyncLogBtn">Clear Log</button>
            </div>
        </div>
    </div>

    <div id="did" class="tabcontent">
        <div class="container">
            <div class="card">
                <h2>DID Nostr Lookup</h2>
                <p>Look up a DID document for a Nostr public key</p>

                <div>
                    <input id="didPubkey" type="text" placeholder="Enter a 64-character public key (hex)"
                        value="cede5ff5916f089b3306ab9cd33c4a952043249dc7803a5ad208b16c5027b2e9">
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="lookupDidBtn">Lookup DID Document</button>
                        <button id="validateDidPubkeyBtn">Validate Format</button>
                    </div>
                    <div id="didValidationResult" class="status" style="display: none;"></div>
                </div>

                <div style="margin-top: 20px;">
                    <h3>DID Document URL</h3>
                    <div id="didUrl"
                        style="margin-bottom: 10px; overflow-wrap: break-word; word-break: break-all; padding: 8px; background-color: #f0f0f0; border-radius: 4px;">
                    </div>
                    <button id="openDidUrlBtn" style="display: none;">Open URL</button>
                </div>
            </div>

            <div class="card">
                <h2>DID Document</h2>
                <pre id="didDocument"
                    style="white-space: pre-wrap; overflow-x: auto; background-color: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 400px; overflow-y: auto;"></pre>
            </div>
        </div>
    </div>

    <script>
        let socket;
        let externalRelays = {};
        let isSyncing = false;
        let syncStats = {
            totalEvents: 0,
            processedEvents: 0,
            successfulEvents: 0,
            failedEvents: 0
        };

        document.getElementById('connectBtn').addEventListener('click', connectWebSocket);
        document.getElementById('disconnectBtn').addEventListener('click', disconnectWebSocket);
        document.getElementById('sendBtn').addEventListener('click', sendMessage);
        document.getElementById('clearLogBtn').addEventListener('click', clearLog);
        document.getElementById('broadcastBtn').addEventListener('click', broadcastMessage);
        document.getElementById('subscribeBtn').addEventListener('click', sendSubscription);
        document.getElementById('unsubscribeBtn').addEventListener('click', sendUnsubscription);
        document.getElementById('sendEventBtn').addEventListener('click', sendEvent);

        // Sync tab event listeners
        document.getElementById('addRelayBtn').addEventListener('click', addRelayInput);
        document.getElementById('testRelaysBtn').addEventListener('click', testRelayConnections);
        document.getElementById('startSyncBtn').addEventListener('click', startSync);
        document.getElementById('stopSyncBtn').addEventListener('click', stopSync);
        document.getElementById('clearSyncLogBtn').addEventListener('click', clearSyncLog);

        // DID lookup tab event listeners
        document.getElementById('lookupDidBtn').addEventListener('click', lookupDid);
        document.getElementById('validateDidPubkeyBtn').addEventListener('click', validateDidPubkey);
        document.getElementById('openDidUrlBtn').addEventListener('click', openDidUrl);

        // Set up initial relay remove buttons
        setupRelayRemoveButtons();

        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }

            const tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        function setupRelayRemoveButtons() {
            const removeButtons = document.querySelectorAll('.remove-relay');
            removeButtons.forEach(button => {
                button.addEventListener('click', function () {
                    const relayItem = this.parentNode;
                    const relayUrl = relayItem.querySelector('.relay-url').value;

                    // Close connection if exists
                    if (externalRelays[relayUrl]) {
                        try {
                            externalRelays[relayUrl].close();
                            delete externalRelays[relayUrl];
                        } catch (e) {
                            console.error("Error closing relay connection:", e);
                        }
                    }

                    // Remove the relay input
                    relayItem.remove();
                });
            });
        }

        function addRelayInput() {
            const relayList = document.getElementById('relayList');
            const newRelayItem = document.createElement('div');
            newRelayItem.className = 'relay-item';
            newRelayItem.innerHTML = `
                <input type="text" class="relay-url" placeholder="wss://relay.example.com">
                <button class="remove-relay">Remove</button>
                <span class="relay-status"></span>
            `;
            relayList.appendChild(newRelayItem);

            // Add event listener to the new remove button
            newRelayItem.querySelector('.remove-relay').addEventListener('click', function () {
                const relayUrl = newRelayItem.querySelector('.relay-url').value;

                // Close connection if exists
                if (externalRelays[relayUrl]) {
                    try {
                        externalRelays[relayUrl].close();
                        delete externalRelays[relayUrl];
                    } catch (e) {
                        console.error("Error closing relay connection:", e);
                    }
                }

                newRelayItem.remove();
            });
        }

        function testRelayConnections() {
            syncLog('Testing relay connections...');
            const relayItems = document.querySelectorAll('.relay-item');

            relayItems.forEach(item => {
                const urlInput = item.querySelector('.relay-url');
                const statusSpan = item.querySelector('.relay-status');
                const relayUrl = urlInput.value.trim();

                if (!relayUrl) {
                    statusSpan.textContent = '❌ No URL provided';
                    return;
                }

                statusSpan.textContent = 'Connecting...';

                try {
                    // Close existing connection if any
                    if (externalRelays[relayUrl]) {
                        externalRelays[relayUrl].close();
                    }

                    const ws = new WebSocket(relayUrl);

                    ws.onopen = () => {
                        statusSpan.textContent = '✅ Connected';
                        syncLog(`Connected to ${relayUrl}`);

                        // Test if it's a Nostr relay by sending a simple REQ
                        const testReq = JSON.stringify(["REQ", "test", { "limit": 1 }]);
                        ws.send(testReq);

                        // Close test connection after a short delay
                        setTimeout(() => {
                            try {
                                ws.close();
                            } catch (e) {
                                console.error("Error closing test connection:", e);
                            }
                        }, 2000);
                    };

                    ws.onmessage = (event) => {
                        syncLog(`Received from ${relayUrl}: ${event.data}`);
                    };

                    ws.onerror = (error) => {
                        statusSpan.textContent = '❌ Error';
                        syncLog(`Error connecting to ${relayUrl}: ${error.message || 'Unknown error'}`);
                    };

                    ws.onclose = () => {
                        if (statusSpan.textContent !== '❌ Error') {
                            statusSpan.textContent = '⚠️ Closed';
                        }
                    };
                } catch (error) {
                    statusSpan.textContent = '❌ Invalid URL';
                    syncLog(`Invalid relay URL ${relayUrl}: ${error.message}`);
                }
            });
        }

        function connectToRelays() {
            const relayItems = document.querySelectorAll('.relay-item');
            const connectedRelays = [];

            relayItems.forEach(item => {
                const urlInput = item.querySelector('.relay-url');
                const statusSpan = item.querySelector('.relay-status');
                const relayUrl = urlInput.value.trim();

                if (!relayUrl) return;

                try {
                    // Close existing connection if any
                    if (externalRelays[relayUrl]) {
                        externalRelays[relayUrl].close();
                    }

                    statusSpan.textContent = 'Connecting...';

                    const ws = new WebSocket(relayUrl);
                    externalRelays[relayUrl] = ws;

                    ws.onopen = () => {
                        statusSpan.textContent = '✅ Connected';
                        syncLog(`Connected to ${relayUrl}`);
                        connectedRelays.push(relayUrl);
                    };

                    ws.onmessage = (event) => {
                        handleExternalRelayMessage(relayUrl, event.data);
                    };

                    ws.onerror = (error) => {
                        statusSpan.textContent = '❌ Error';
                        syncLog(`Error with ${relayUrl}: ${error.message || 'Unknown error'}`);
                    };

                    ws.onclose = () => {
                        if (statusSpan.textContent !== '❌ Error') {
                            statusSpan.textContent = '⚠️ Closed';
                        }
                        syncLog(`Disconnected from ${relayUrl}`);
                    };
                } catch (error) {
                    statusSpan.textContent = '❌ Invalid URL';
                    syncLog(`Invalid relay URL ${relayUrl}: ${error.message}`);
                }
            });

            return new Promise((resolve) => {
                // Wait a bit for connections to establish
                setTimeout(() => {
                    resolve(Object.keys(externalRelays).filter(url => externalRelays[url].readyState === WebSocket.OPEN));
                }, 2000);
            });
        }

        function startSync() {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                syncLog('❌ Please connect to local relay first');
                return;
            }

            isSyncing = true;
            document.getElementById('startSyncBtn').disabled = true;
            document.getElementById('stopSyncBtn').disabled = false;
            document.getElementById('syncProgress').style.display = 'block';

            // Reset sync stats
            syncStats = {
                totalEvents: 0,
                processedEvents: 0,
                successfulEvents: 0,
                failedEvents: 0
            };
            updateSyncStats();

            syncLog('Starting synchronization...');

            connectToRelays().then(connectedRelays => {
                if (connectedRelays.length === 0) {
                    syncLog('❌ No relays connected. Sync aborted.');
                    stopSync();
                    return;
                }

                syncLog(`Connected to ${connectedRelays.length} relays`);

                const syncKind10002 = document.getElementById('syncKind10002').checked;
                const syncKind3 = document.getElementById('syncKind3').checked;
                const limit = parseInt(document.getElementById('syncLimit').value) || 50;

                // Create filters
                const filters = [];

                if (syncKind10002) {
                    filters.push({ kinds: [10002], limit });
                }

                if (syncKind3) {
                    filters.push({ kinds: [3], limit });
                }

                if (filters.length === 0) {
                    syncLog('❌ No kind selected for syncing. Sync aborted.');
                    stopSync();
                    return;
                }

                // Send REQ to each relay
                connectedRelays.forEach(relayUrl => {
                    if (!isSyncing) return;

                    const relay = externalRelays[relayUrl];
                    if (relay && relay.readyState === WebSocket.OPEN) {
                        const subscriptionId = `sync:${Date.now()}:${Math.floor(Math.random() * 1000)}`;

                        const reqMessage = ["REQ", subscriptionId, ...filters];
                        relay.send(JSON.stringify(reqMessage));

                        syncLog(`Requested data from ${relayUrl}: ${JSON.stringify(filters)}`);

                        // Set a timeout to close the subscription
                        setTimeout(() => {
                            if (relay.readyState === WebSocket.OPEN && isSyncing) {
                                relay.send(JSON.stringify(["CLOSE", subscriptionId]));
                                syncLog(`Closed subscription ${subscriptionId} to ${relayUrl}`);
                            }
                        }, 30000); // 30 seconds timeout
                    }
                });
            });
        }

        function stopSync() {
            isSyncing = false;
            document.getElementById('startSyncBtn').disabled = false;
            document.getElementById('stopSyncBtn').disabled = true;
            document.getElementById('syncProgress').style.display = 'none';

            // Close all external relay connections
            Object.keys(externalRelays).forEach(url => {
                try {
                    if (externalRelays[url].readyState === WebSocket.OPEN) {
                        externalRelays[url].close();
                    }
                    delete externalRelays[url];
                } catch (e) {
                    console.error(`Error closing connection to ${url}:`, e);
                }
            });

            // Update UI
            const relayItems = document.querySelectorAll('.relay-item');
            relayItems.forEach(item => {
                const statusSpan = item.querySelector('.relay-status');
                statusSpan.textContent = '';
            });

            syncLog('Synchronization stopped');
        }

        function handleExternalRelayMessage(relayUrl, data) {
            if (!isSyncing) return;

            try {
                const message = JSON.parse(data);

                if (message[0] === 'EVENT' && message.length >= 3) {
                    const event = message[2];

                    // Increment total events counter
                    syncStats.totalEvents++;

                    syncLog(`Received event kind ${event.kind} from ${relayUrl}`);

                    // Forward event to local relay
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify(["EVENT", event]));
                        syncStats.processedEvents++;
                        syncStats.successfulEvents++;
                        syncLog(`Forwarded event to local relay: ${event.id.substring(0, 8)}...`);
                    } else {
                        syncStats.failedEvents++;
                        syncLog('❌ Local relay not connected, cannot forward event');
                    }

                    updateSyncStats();
                } else if (message[0] === 'EOSE') {
                    syncLog(`End of stored events from ${relayUrl}`);
                } else if (message[0] === 'NOTICE') {
                    syncLog(`Notice from ${relayUrl}: ${message[1]}`);
                }
            } catch (error) {
                syncLog(`Error processing message from ${relayUrl}: ${error.message}`);
                console.error("Failed to parse message:", data, error);
            }
        }

        function updateSyncStats() {
            const progress = syncStats.totalEvents > 0 ?
                (syncStats.processedEvents / syncStats.totalEvents) * 100 : 0;

            document.getElementById('syncProgress').value = progress;

            document.getElementById('syncStats').innerHTML = `
                Events found: ${syncStats.totalEvents}<br>
                Processed: ${syncStats.processedEvents}<br>
                Successful: ${syncStats.successfulEvents}<br>
                Failed: ${syncStats.failedEvents}
            `;
        }

        function syncLog(message) {
            const logElem = document.getElementById('syncLog');
            const timestamp = new Date().toISOString().substring(11, 19);
            logElem.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logElem.scrollTop = logElem.scrollHeight;
        }

        function clearSyncLog() {
            document.getElementById('syncLog').innerHTML = '';
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/`;

            log(`Connecting to ${wsUrl}...`);

            socket = new WebSocket(wsUrl);

            socket.onopen = function (event) {
                updateConnectionStatus(true);
                log('Connection established');
            };

            socket.onmessage = function (event) {
                log(`Received: ${event.data}`);
            };

            socket.onerror = function (error) {
                log('WebSocket Error: ' + JSON.stringify(error));
            };

            socket.onclose = function (event) {
                updateConnectionStatus(false);
                log(`Connection closed. Code: ${event.code}, Reason: ${event.reason}`);
            };
        }

        function disconnectWebSocket() {
            if (socket) {
                socket.close();
            }
        }

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (message && socket && socket.readyState === WebSocket.OPEN) {
                socket.send(message);
                log(`Sent: ${message}`);
                messageInput.value = '';
            }
        }

        function sendSubscription() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const subscriptionId = document.getElementById('subscriptionId').value.trim();
                const authorId = document.getElementById('authorId').value.trim();
                const kindId = parseInt(document.getElementById('kindId').value.trim());

                // Create Nostr REQ message
                const reqMessage = [
                    "REQ",
                    subscriptionId,
                    {
                        "kinds": [kindId],
                        "authors": [authorId],
                        "limit": 10
                    }
                ];

                const message = JSON.stringify(reqMessage);
                socket.send(message);
                log(`Sent REQ: ${message}`);
            }
        }

        function sendUnsubscription() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const subscriptionId = document.getElementById('closeSubscriptionId').value.trim();

                // Create Nostr CLOSE message
                const closeMessage = [
                    "CLOSE",
                    subscriptionId
                ];

                const message = JSON.stringify(closeMessage);
                socket.send(message);
                log(`Sent CLOSE: ${message}`);
            }
        }

        function broadcastMessage() {
            const message = document.getElementById('broadcastInput').value.trim();

            if (message) {
                fetch('/api/broadcast', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message })
                })
                    .then(response => response.json())
                    .then(data => {
                        log(`Broadcast API Response: ${JSON.stringify(data)}`);
                    })
                    .catch(error => {
                        log(`Error broadcasting: ${error}`);
                    });
            }
        }

        function updateConnectionStatus(isConnected) {
            const statusElem = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const sendBtn = document.getElementById('sendBtn');
            const subscribeBtn = document.getElementById('subscribeBtn');
            const unsubscribeBtn = document.getElementById('unsubscribeBtn');
            const sendEventBtn = document.getElementById('sendEventBtn');

            if (isConnected) {
                statusElem.textContent = 'Connected';
                statusElem.className = 'status connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                sendBtn.disabled = false;
                subscribeBtn.disabled = false;
                unsubscribeBtn.disabled = false;
                sendEventBtn.disabled = false;
            } else {
                statusElem.textContent = 'Disconnected';
                statusElem.className = 'status disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                sendBtn.disabled = true;
                subscribeBtn.disabled = true;
                unsubscribeBtn.disabled = true;
                sendEventBtn.disabled = true;
            }
        }

        function sendEvent() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const pubkey = document.getElementById('eventPubkey').value.trim();
                const kind = parseInt(document.getElementById('eventKind').value.trim());
                const content = document.getElementById('eventContent').value.trim();
                let id = document.getElementById('eventId').value.trim();
                let sig = document.getElementById('eventSig').value.trim();

                // For testing purposes, generate random ID and signature if not provided
                if (!id) {
                    id = Array.from({ length: 64 }, () =>
                        Math.floor(Math.random() * 16).toString(16)).join('');
                    document.getElementById('eventId').value = id;
                }

                if (!sig) {
                    sig = Array.from({ length: 128 }, () =>
                        Math.floor(Math.random() * 16).toString(16)).join('');
                    document.getElementById('eventSig').value = sig;
                }

                // Create Nostr EVENT message
                const event = {
                    id: id,
                    pubkey: pubkey,
                    created_at: Math.floor(Date.now() / 1000),
                    kind: kind,
                    tags: [],
                    content: content,
                    sig: sig
                };

                const eventMessage = [
                    "EVENT",
                    event
                ];

                const message = JSON.stringify(eventMessage);
                socket.send(message);
                log(`Sent EVENT: ${message}`);
            }
        }

        function log(message) {
            const logElem = document.getElementById('log');
            const timestamp = new Date().toISOString().substring(11, 19);
            logElem.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logElem.scrollTop = logElem.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function lookupDid() {
            const pubkey = document.getElementById('didPubkey').value.trim();
            if (!pubkey) {
                showDidValidation('Please enter a public key', false);
                return;
            }

            if (!validateHexPubkey(pubkey)) {
                showDidValidation('Invalid public key format. Must be 64 hex characters.', false);
                return;
            }

            const url = `/.well-known/did/nostr/${pubkey}.json`;
            document.getElementById('didUrl').textContent = `${window.location.origin}${url}`;
            document.getElementById('openDidUrlBtn').style.display = 'inline-block';

            // Fetch the DID document
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    document.getElementById('didDocument').textContent = JSON.stringify(data, null, 2);
                    showDidValidation('DID document retrieved successfully', true);
                })
                .catch(error => {
                    document.getElementById('didDocument').textContent = `Error: ${error.message}`;
                    showDidValidation(`Failed to retrieve DID document: ${error.message}`, false);
                });
        }

        function validateDidPubkey() {
            const pubkey = document.getElementById('didPubkey').value.trim();
            if (!pubkey) {
                showDidValidation('Please enter a public key', false);
                return;
            }

            if (validateHexPubkey(pubkey)) {
                showDidValidation('Valid public key format', true);

                // Update the URL display
                const url = `/.well-known/did/nostr/${pubkey}.json`;
                document.getElementById('didUrl').textContent = `${window.location.origin}${url}`;
                document.getElementById('openDidUrlBtn').style.display = 'inline-block';
            } else {
                showDidValidation('Invalid public key format. Must be 64 hex characters.', false);
                document.getElementById('didUrl').textContent = '';
                document.getElementById('openDidUrlBtn').style.display = 'none';
            }
        }

        function validateHexPubkey(pubkey) {
            return /^[0-9a-fA-F]{64}$/.test(pubkey);
        }

        function showDidValidation(message, isValid) {
            const validationElem = document.getElementById('didValidationResult');
            validationElem.textContent = message;
            validationElem.style.display = 'block';

            if (isValid) {
                validationElem.className = 'status connected';
            } else {
                validationElem.className = 'status disconnected';
            }
        }

        function openDidUrl() {
            const url = document.getElementById('didUrl').textContent;
            if (url) {
                window.open(url, '_blank');
            }
        }

        // NIP-11 Information Handling
        document.addEventListener('DOMContentLoaded', function () {
            fetchNip11Info();

            document.getElementById('refresh-nip11-btn').addEventListener('click', fetchNip11Info);
        });

        function fetchNip11Info() {
            const nip11Loading = document.getElementById('nip11-loading');
            const nip11Data = document.getElementById('nip11-data');
            const nip11Error = document.getElementById('nip11-error');

            nip11Loading.style.display = 'block';
            nip11Data.style.display = 'none';
            nip11Error.style.display = 'none';

            // Make NIP-11 request
            fetch('/', {
                headers: {
                    'Accept': 'application/nostr+json'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Display the NIP-11 data
                    document.getElementById('relay-name').textContent = data.name || '-';
                    document.getElementById('relay-description').textContent = data.description || '-';
                    document.getElementById('relay-contact').textContent = data.contact || '-';
                    document.getElementById('relay-software').textContent = data.software || '-';
                    document.getElementById('relay-version').textContent = data.version || '-';

                    // Format NIPs
                    const nipsContainer = document.getElementById('relay-nips');
                    if (data.supported_nips && data.supported_nips.length) {
                        nipsContainer.innerHTML = '';
                        data.supported_nips.forEach(nip => {
                            const nipElement = document.createElement('span');
                            nipElement.classList.add('nip-tag');
                            nipElement.textContent = `NIP-${nip}`;
                            nipsContainer.appendChild(nipElement);
                        });
                    } else {
                        nipsContainer.textContent = '-';
                    }

                    // Limitations
                    if (data.limitation) {
                        let limitationsText = '';
                        if (data.limitation.max_message_length) {
                            limitationsText += `Max message: ${data.limitation.max_message_length} bytes\n`;
                        }
                        if (data.limitation.max_subscriptions) {
                            limitationsText += `Max subscriptions: ${data.limitation.max_subscriptions}\n`;
                        }
                        if (data.limitation.max_filters) {
                            limitationsText += `Max filters: ${data.limitation.max_filters}\n`;
                        }
                        if (data.limitation.max_limit) {
                            limitationsText += `Max limit: ${data.limitation.max_limit}\n`;
                        }
                        if (data.limitation.max_subid_length) {
                            limitationsText += `Max sub ID length: ${data.limitation.max_subid_length}\n`;
                        }
                        if (data.limitation.max_event_tags) {
                            limitationsText += `Max event tags: ${data.limitation.max_event_tags}\n`;
                        }
                        if (data.limitation.max_content_length) {
                            limitationsText += `Max content length: ${data.limitation.max_content_length}\n`;
                        }
                        document.getElementById('relay-limitations').innerHTML = limitationsText.replace(/\n/g, '<br>');
                    } else {
                        document.getElementById('relay-limitations').textContent = '-';
                    }

                    // Retention
                    if (data.retention) {
                        let retentionText = '';
                        if (data.retention.posts) {
                            retentionText += `Posts: ${data.retention.posts}\n`;
                        }
                        if (data.retention.events) {
                            retentionText += `Events: ${data.retention.events}\n`;
                        }
                        document.getElementById('relay-retention').innerHTML = retentionText.replace(/\n/g, '<br>') || '-';
                    } else {
                        document.getElementById('relay-retention').textContent = '-';
                    }

                    // Other fields
                    document.getElementById('relay-fees').textContent = formatFees(data) || '-';
                    document.getElementById('relay-publish').textContent = formatPolicy(data.publication_policy) || '-';
                    document.getElementById('relay-privacy').innerHTML =
                        data.privacy_policy ? `<a href="${data.privacy_policy}" target="_blank">${data.privacy_policy}</a>` : '-';

                    // Show the data section
                    nip11Loading.style.display = 'none';
                    nip11Data.style.display = 'block';
                })
                .catch(error => {
                    nip11Loading.style.display = 'none';
                    nip11Error.style.display = 'block';
                    nip11Error.textContent = `Error fetching NIP-11 information: ${error.message}`;
                    console.error('NIP-11 fetch error:', error);
                });
        }

        function formatFees(data) {
            if (!data.fees) return '-';

            let feesText = '';
            if (data.fees.admission && data.fees.admission.length > 0) {
                feesText += 'Admission: ' + data.fees.admission.map(fee =>
                    `${fee.amount} ${fee.unit}`).join(', ') + '\n';
            }
            if (data.fees.subscription && data.fees.subscription.length > 0) {
                feesText += 'Subscription: ' + data.fees.subscription.map(fee =>
                    `${fee.amount} ${fee.unit} per ${fee.period}`).join(', ') + '\n';
            }
            if (data.fees.publication && data.fees.publication.length > 0) {
                feesText += 'Publication: ' + data.fees.publication.map(fee =>
                    `${fee.amount} ${fee.unit}`).join(', ');
            }

            return feesText.replace(/\n/g, '<br>') || '-';
        }

        function formatPolicy(policy) {
            if (!policy) return '-';
            if (typeof policy === 'string') return policy;
            if (typeof policy === 'object') return JSON.stringify(policy);
            return '-';
        }
    </script>
</body>

</html>